#include "config.h"
#include "clock_display.h"
#include "stepper_controller.h"
#include <random_seed.h>
#include <Adafruit_NeoPixel.h>
#include <Stepper.h>
#include <Wire.h>
#include <DS3231-RTC.h>
#include <math.h>

// Hardware instances
DS3231 rtc;
Stepper stepperMotor(STEPS_PER_REVOLUTION, FIRST_MOTOR_PIN, FIRST_MOTOR_PIN+1, FIRST_MOTOR_PIN+2, FIRST_MOTOR_PIN+3);
Adafruit_NeoPixel pixels(TOTAL_LEDS, NEOPIXEL_PIN, NEO_GRB + NEO_KHZ800);
static RandomSeed<RANDOM_SEED_PIN> randomizer;

// Controller instances
ClockDisplay display(pixels);
StepperController stepperController(stepperMotor, SENSOR_PIN, CENTERING_ADJUSTMENT);

// State variables
int lastSecond = -1;
int lastMinute = -1;
int lastHour = -1;
unsigned long lastUpdate = 0;
bool setupComplete = false;

// Display modes
enum DisplayMode {
    NORMAL_TIME,
    RAINBOW_MODE,
    TEMPERATURE_MODE,
    DATE_MODE,
    CALIBRATION_MODE
};

DisplayMode currentMode = NORMAL_TIME;
unsigned long modeChangeTime = 0;
const unsigned long MODE_DURATION = 10000; // 10 seconds per special mode

void setup() {
    Serial.begin(115200);
    Serial.println("\n=== Hybrid Clock Starting ===");
    
    // Initialize random seed
    randomizer.randomize();
    
    // Initialize I2C for RTC
    Wire.begin();
    
    // Initialize display
    display.begin();
    display.showStartupAnimation();
    
    // Initialize stepper controller
    stepperController.begin();
    
    // Show calibration pattern
    display.showCalibrationPattern();
    
    // Calibrate stepper motor
    Serial.println("Calibrating stepper motor...");
    if (stepperController.calibrate()) {
        Serial.println("Calibration successful!");
        display.setPixelColor(0, display.Color(0, 255, 0)); // Green for success
    } else {
        Serial.println("Calibration failed!");
        display.setPixelColor(0, display.Color(255, 0, 0)); // Red for failure
    }
    display.show();
    delay(CALIBRATION_DISPLAY_TIME);
    
    // Verify calibration
    if (stepperController.verifyCalibration()) {
        Serial.println("Calibration verified!");
    } else {
        Serial.println("Warning: Calibration verification failed");
    }
    
    setupComplete = true;
    lastUpdate = millis();
    
    // Show initial time for debugging
    bool century = false;
    bool h12Flag = false;
    bool pm = false;
    int initialHour = rtc.getHour(h12Flag, pm);
    int initialMinute = rtc.getMinute();
    int initialSecond = rtc.getSecond();
    
    Serial.print("=== Initial Time: ");
    Serial.print(initialHour);
    Serial.print(":");
    Serial.print(initialMinute < 10 ? "0" : "");
    Serial.print(initialMinute);
    Serial.print(":");
    Serial.print(initialSecond < 10 ? "0" : "");
    Serial.print(initialSecond);
    Serial.println(" ===");
    
    // Move hand to current minute immediately
    stepperController.moveToMinute(initialMinute);
    
    Serial.println("=== Setup Complete ===\n");
}

void loop() {
    if (!setupComplete) return;
    
    // Read current time
    bool century = false;
    bool h12Flag = false;
    bool pm = false;
    
    int currentSecond = rtc.getSecond();
    
    // Only update once per second
    if (currentSecond == lastSecond) {
        delay(RTC_CHECK_DELAY);
        return;
    }
    
    lastSecond = currentSecond;
    
    // Get complete time
    int year = rtc.getYear();
    int month = rtc.getMonth(century);
    int day = rtc.getDate();
    int hour = rtc.getHour(h12Flag, pm);
    int minute = rtc.getMinute();
    
    // Suppress unused variable warnings
    (void)year;
    
    // Move stepper hand (once per minute to avoid accumulated errors)
    if (minute != lastMinute) {
        Serial.print("Time: ");
        Serial.print(hour);
        Serial.print(":");
        Serial.print(minute < 10 ? "0" : "");
        Serial.print(minute);
        Serial.print(":");
        Serial.print(currentSecond < 10 ? "0" : "");
        Serial.println(currentSecond);
        
        stepperController.moveToMinute(minute);
        lastMinute = minute;
    }
    
    // Always display the current time (don't let modes override basic functionality)
    display.updateTime(hour, minute, currentSecond);
    
    // Check for special display effects (brief, non-intrusive)
    handleDisplayModes(hour, minute, currentSecond, day, month);
    
    // Check for special events
    handleSpecialEvents(hour, minute, currentSecond);
    
    lastHour = hour;
}

void handleDisplayModes(int hour, int minute, int second, int day, int month) {
    unsigned long currentTime = millis();
    
    // Special modes only activate occasionally and briefly (every 2 minutes for 5 seconds)
    if (currentTime - modeChangeTime > 120000) { // 2 minutes
        if (second >= 0 && second <= 5) { // Show for 5 seconds only
            // Cycle through special modes occasionally
            DisplayMode specialMode = (DisplayMode)((currentTime / 120000) % 3 + 1); // Modes 1-3
            
            switch (specialMode) {
                case RAINBOW_MODE:
                    display.showRainbowMode();
                    return; // Skip normal time display
                    
                case TEMPERATURE_MODE: {
                    float simulatedTemp = 15.0 + sin(hour * 0.26) * 10.0;
                    display.showTemperatureMode(simulatedTemp);
                    return; // Skip normal time display
                }
                    
                case DATE_MODE:
                    display.showDateMode(day, month);
                    return; // Skip normal time display
                    
                default:
                    break;
            }
        }
        
        if (second > 5) {
            modeChangeTime = currentTime; // Reset timer after special display
        }
    }
    
    // Normal time display (most of the time)
    // This will be called from main loop, so we don't need to do anything here
}

void handleSpecialEvents(int hour, int minute, int second) {
    // Top of the hour animation
    if (minute == 0 && second == 0 && hour != lastHour) {
        Serial.println("Hour changed - showing special animation");
        display.showHourChange(hour);
        
        // Optional: recalibrate at midnight
        if (hour == 0) {
            Serial.println("Midnight recalibration check");
            if (!stepperController.verifyCalibration()) {
                Serial.println("Recalibrating...");
                stepperController.calibrate();
            }
        }
    }
    
    // Test mode activation (hold button simulation - in real hardware you'd read a button)
    // For demo, activate test mode every 10 minutes
    if (minute % 10 == 0 && second == 30) {
        // Quick sweep test
        Serial.println("Performing sweep test");
        stepperController.sweepTest();
    }
}